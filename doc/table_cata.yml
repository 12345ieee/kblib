header:
  - name: ['Name', ['rowname']]
  - Inp: ['Input ranges<a href="#fn-stagger" class="fn-ref">*</a>', ['Inp']]
  - Acc: ['Accumu&shy;lator', ['Acc']]
  - Ret: ['Returns<a href="#fn-position" class="fn-ref">&target;</a>', ['Ret']]
  - Ops: ['Operations<a href="#fn-opabbrs" class="fn-ref">&dagger;</a>', ['Ops']]
  - Def: ['Default operations', ['Def']]
  - Cpx: ['Compl&shy;exity', ['Cpx']]
  - Dir: ['Order<a href="#fn-order" class="fn-ref">&ddagger;</a>', ['Dir']]
  - Cmp: ['Compare to', ['Cmp']]
  - Family: ['Family', ['Family', 'hidden']]

data:
  - name: '{std:inner_@product}'
    Inp: '2'
    Acc: 'Arg'
    Ret: 'Value'
    Ops: 'A, bT'
    Def: '{std:plus}, {std:multiplies}'
    Cpx: 'Unspc.'
    Dir: 'Fwd.'
    Cmp: '{std:transform_@reduce}'
    Family: '10'
  - name: '{CH:adjacent_@reduce}{&rtrif;|YT:sEvYmb3eKsw?t=}'
    Inp: '1s'
    Acc: 'Arg'
    Ret: 'Value'
    Ops: 'A, bT'
    Def: ''
    Cpx: 'Unspc.'
    Dir: 'Fwd.'
    Cmp: '{std:inner_@product}'
    Family: '10'

  - name: '{std:transform_@reduce}'
    Inp: '1 / 2'
    Acc: 'Arg'
    Ret: 'Value'
    Ops: 'acR, uT / bT'
    Def: '{std:plus}, {std:multiplies}'
    Cpx: 'O(N)'
    Dir: '{^&par;|FN:par}'
    Cmp: ''
    Family: '20'

  - name: '{std:find}'
    Inp: '1+Value'
    Acc: ''
    Ret: 'Position'
    Ops: ''
    Def: '{std:equal_to}'
    Cpx: 'O(N)'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: ''
    Family: '70'
  - name: '{std:find_if}, {std:find_@if_not}'
    Inp: '1'
    Acc: ''
    Ret: 'Position'
    Ops: 'uP'
    Def: ''
    Cpx: 'O(N)'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: ''
    Family: '70'
  - name: '{std:find_@first_of}'
    Inp: '2'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'O(S×N)'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: '{std:find_if}'
    Family: '70'

  - name: '{std:min_@element}, {std:max_@element}'
    Inp: '1'
    Acc: 'First'
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N), =(max(N-1, 0))'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: ''
    Family: '72'
  - name: '{std:minmax_@element}'
    Inp: '1'
    Acc: 'First'
    Ret: '2 Positions{^&target;|FN:position}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N), &leq;(max(floor((3/2)*(N−1)), 0))'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: ''
    Family: '72'

  - name: '{std:lower_@bound}, {std:upper_@bound}'
    Inp: '1+Value'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(log N) + O(1){^&darr;R|FN:raccess}; O(N)'
    Dir: 'B/S'
    Cmp: ''
    Family: '75'
  - name: '{std:equal_@range}'
    Inp: '1+Value'
    Acc: ''
    Ret: 'Range{^&target;|FN:position}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(log N) + O(1){^&darr;R|FN:raccess}; O(N)'
    Dir: 'B/S'
    Cmp: ''
    Family: '75'

  - name: '{std:search}'
    Inp: '2'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: '&leq;(S×N)'
    Dir: '{^&par;|FN:par}'
    Cmp: ''
    Family: '80'
  - name: '{std:find_end}'
    Inp: '2'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: '&leq;(S×(N-S+1))'
    Dir: '{^&par;|FN:par}'
    Cmp: '{std:search}'
    Family: '80'
  - name: '{kblib:starts_@with}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'N &gt; S ? O(S) : O(1){^&darr;R|FN:raccess}; O(min(S, N))'
    Dir: 'Fwd.'
    Cmp: ''
    Family: '80'
  - name: '{kblib:ends_@with}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'N &gt; S ? O(S) : O(1){^&darr;R|FN:raccess}; O(min(S, N))'
    Dir: ''
    Cmp: ''
    Family: '80'
  - name: '{std:ranges::starts_@with}, {std:ranges::ends_@with}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP, uT, uT{^&Delta;|FN:3way}'
    Def: '{std:equal_to}, {std:identity}, {std:identity}'
    Cpx: '&leq;(min(S, N))'
    Dir: ''
    Cmp: ''
    Family: '80'

  - name: '{search (C++17)|std:search}'
    Inp: '1'
    Acc: ''
    Ret: 'Position'
    Ops: 'Searcher'
    Def: ''
    Cpx: 'Depends on Searcher'
    Dir: ''
    Cmp: ''
    Family: '85'

  - name: '{kblib:find_@match}'
    Inp: '2'
    Acc: ''
    Ret: 'Position{^&target;|FN:position}'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'O(N), O(min(N, M))'
    Dir: 'S/C'
    Cmp: ''
    Family: '90'
  - name: '{std:mismatch}'
    Inp: '2'
    Acc: ''
    Ret: 'Position{^&target;|FN:position}'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'O(N), O(min(N, M))'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: '{kblib:find_match}'
    Family: '90'
  - name: '{std:adjacent_@find}'
    Inp: '1s'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: '=(min((result-first)+1, (last-first)-1)); O(N){^&darr;&par;|FN:raccess}'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: '{kblib:find_match}'
    Family: '90'
  - name: '{std:is_sorted_@until}'
    Inp: '1s'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N)'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: '{kblib:find_match}'
    Family: '90'

  - name: '{std:search_n}'
    Inp: '1 + Count + Value'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: '&leq;(N)'
    Dir: '{^&par;|FN:par}'
    Cmp: '{std:adjacent_@find}'
    Family: '95'

  - name: '{std:accumulate}'
    Inp: '1'
    Acc: 'Arg'
    Ret: 'Value'
    Ops: 'A'
    Def: '{std:plus}'
    Cpx: 'Unspc.; <span class="kblib">O(N)</span>'
    Dir: 'Fwd.'
    Cmp: ''
    Family: '110'
  - name: '{kblib:sum}'
    Inp: '1'
    Acc: 'First'
    Ret: 'Value'
    Ops: 'R'
    Def: '{std:plus}'
    Cpx: 'O(N)'
    Dir: 'Fwd.'
    Cmp: '{std:accumulate}'
    Family: '110'
  - name: '{std:reduce}'
    Inp: '1'
    Acc: 'Arg'
    Ret: 'Value'
    Ops: 'acR'
    Def: '{std:plus}'
    Cpx: 'O(N)'
    Dir: '{^&par;|FN:par}'
    Cmp: ''
    Family: '110'
  - name: '{std:count}'
    Inp: '1+Value'
    Acc: '{:0}'
    Ret: '{std:size_t}'
    Ops: ''
    Def: '{std:equal_to}'
    Cpx: '=(N)'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: '{std:accumulate}'
    Family: '110'
  - name: '{std:count_if}'
    Inp: '1'
    Acc: '{:0}'
    Ret: '{std:size_t}'
    Ops: 'uP'
    Def: ''
    Cpx: '=(N)'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: '{std:accumulate}'
    Family: '110'
  - name: '{std:binary_@search}'
    Inp: '1+Value'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(log N) + O(1){^&darr;R|FN:raccess}; O(N)'
    Dir: 'B/S'
    Cmp: ''
    Family: '110'

  - name: '{std:is_partitioned}'
    Inp: '1'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'uP'
    Def: ''
    Cpx: 'O(N)'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: ''
    Family: '120'
  - name: '{std:is_sorted}'
    Inp: '1'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N)'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: ''
    Family: '120'
  - name: '{std:is_heap}'
    Inp: '1'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N)'
    Dir: '{^&par;|FN:par}'
    Cmp: ''
    Family: '120'
  - name: '{std:is_permutation}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'N==M ? O(N<sup>2</sup>) : O(1){^&darr;R|FN:raccess}; O(N<sup>2</sup>)'
    Dir: ''
    Cmp: ''
    Family: '120'
  - name: '{std:includes}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N+M), &leq;(2×(N+M-1))'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: ''
    Family: '120'

  - name: '{kblib:first_result}'
    Inp: '1+Value / 2+Value'
    Acc: 'Arg'
    Ret: 'Value'
    Ops: 'uT / bT'
    Def: ''
    Cpx: 'O(N)'
    Dir: 'S/C'
    Cmp: ''
    Family: '125'
  - name: '{kblib:first_@result_if}'
    Inp: '1 / 2'
    Acc: ''
    Ret: 'Value'
    Ops: 'uT / bT, uP / bP'
    Def: ''
    Cpx: 'O(N)'
    Dir: 'S/C'
    Cmp: ''
    Family: '125'
  - name: '{std:all_of}, {std:none_of}'
    Inp: '1'
    Acc: '{:true}'
    Ret: '{:bool}'
    Ops: 'uP'
    Def: ''
    Cpx: 'O(N)'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: '{kblib:first_result}'
    Family: '125'
  - name: '{std:any_of}'
    Inp: '1'
    Acc: '{:false}'
    Ret: '{:bool}'
    Ops: 'uP'
    Def: ''
    Cpx: 'O(N)'
    Dir: 'S/C{^&par;|FN:par}'
    Cmp: '{kblib:first_result}'
    Family: '125'
  - name: '{kblib:contains}'
    Inp: '1+Value'
    Acc: '{:false}'
    Ret: '{:bool}'
    Ops: ''
    Def: '{std:equal_to}'
    Cpx: 'O(N)'
    Dir: 'S/C'
    Cmp: '{kblib:first_result}'
    Family: '125'
  - name: '{kblib:contains_@any}'
    Inp: '2'
    Acc: '{:false}'
    Ret: '{:bool}'
    Ops: ''
    Def: '{kblib:contains}'
    Cpx: 'O(S×N)'
    Dir: 'S/C'
    Cmp: '{kblib:first_result}'
    Family: '125'
  - name: '{std:equal}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:equal_to}'
    Cpx: 'N==M ? &leq;(N) : O(1){^&darr;R|FN:raccess}; &leq;(N); O(N){^&darr;&par;|FN:raccess}'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: '{kblib:first_result}'
    Family: '125'
  - name: '{std:lexicographical_@compare}'
    Inp: '2'
    Acc: ''
    Ret: '{:bool}'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: '&leq;(2×min(N, M))'
    Dir: 'Fwd.{^&par;|FN:par}'
    Cmp: '{kblib:first_result}'
    Family: '125'
  - name: '{std:lexicographical_@compare_@three_way}'
    Inp: '2'
    Acc: ''
    Ret: 'ordering'
    Ops: 'Compare{^&Delta;|FN:3way}'
    Def: '{std:compare_@three_way}'
    Cpx: '&lt;(min(N, M))'
    Dir: 'Fwd.'
    Cmp: '{kblib:first_result}'
    Family: '125'

  - name: '{std:partition_@point}'
    Inp: '1'
    Acc: ''
    Ret: 'Position'
    Ops: 'uP'
    Def: ''
    Cpx: 'O(log N){^&darr;R|FN:raccess}; O(N)'
    Dir: 'B/S'
    Cmp: ''
    Family: '130'
  - name: '{std:is_heap_@until}'
    Inp: '1'
    Acc: ''
    Ret: 'Position'
    Ops: 'bP'
    Def: '{std:less}'
    Cpx: 'O(N)'
    Dir: '{^&par;|FN:par}'
    Cmp: ''
    Family: '130'
